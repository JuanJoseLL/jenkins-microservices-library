package com.microservices

class GitHubManager implements Serializable {
    def steps
    
    GitHubManager(steps) {
        this.steps = steps
    }
    
    def installGitHubCLI() {
        steps.echo "📦 Verificando GitHub CLI..."
        
        def ghInstalled = steps.sh(
            script: "command -v gh",
            returnStatus: true
        ) == 0
        
        if (!ghInstalled) {
            steps.echo "📦 Instalando GitHub CLI..."
            steps.sh """
                curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
                echo "deb [arch=\$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
                sudo apt update && sudo apt install gh -y
            """
        } else {
            steps.echo "✅ GitHub CLI ya está instalado"
        }
    }
    
    def createRelease(String tag, String title, String notes, String token) {
        steps.echo "🏷️  Creando release ${tag} en GitHub..."
        
        // Instalar CLI si es necesario
        installGitHubCLI()
        
        // Autenticar con GitHub
        steps.sh """
            echo "${token}" | gh auth login --with-token
        """
        
        // Crear el release
        steps.sh """
            gh release create "${tag}" \
                --title "${title}" \
                --notes "${notes}" \
                --latest
        """
        
        steps.echo "✅ Release ${tag} creado exitosamente"
    }
    
    def tagCommit(String tag, String message) {
        steps.echo "🏷️  Creando tag ${tag}..."
        
        steps.sh """
            git config user.name "Jenkins CI"
            git config user.email "jenkins@ci.local"
            git tag -a "${tag}" -m "${message}"
        """
    }
    
    def pushTag(String tag) {
        steps.echo "📤 Pushing tag ${tag} to origin..."
        
        try {
            steps.sh "git push origin ${tag}"
            steps.echo "✅ Tag ${tag} pushed successfully"
        } catch (Exception e) {
            steps.echo "⚠️  No se pudo hacer push del tag: ${e.getMessage()}"
        }
    }
    
    def generateReleaseNotes(List services, String version, Map buildInfo) {
        def template = """
## 🚀 Release v${version}

### 📦 Microservices Updated:
${services.collect { "- **${it}**" }.join('\n')}

### 🐳 Docker Images Published:
${services.collect { "- `${buildInfo.dockerhubUsername}/${it}:v${version}`" }.join('\n')}
${services.collect { "- `${buildInfo.dockerhubUsername}/${it}:latest`" }.join('\n')}

### 📊 Build Information:
- **Build ID:** ${buildInfo.buildNumber}
- **Branch:** ${buildInfo.branch}
- **Commit:** ${buildInfo.commit?.take(8) ?: 'N/A'}
- **Date:** ${new Date().format('yyyy-MM-dd HH:mm:ss')}
- **Duration:** ${buildInfo.duration}

### 🛡️ Security & Quality:
- ✅ Code Quality Analysis (SonarQube)
- ✅ Security Scanning (Trivy)
- ✅ Unit Tests Passed
- ✅ Integration Tests Passed
- ✅ E2E Tests Passed
- ✅ Load Tests Completed

### 📈 Test Coverage:
- **Unit Tests:** ${buildInfo.unitTestCoverage ?: 'N/A'}
- **Integration Tests:** ${buildInfo.integrationTestCoverage ?: 'N/A'}
- **Overall Coverage:** ${buildInfo.overallCoverage ?: 'N/A'}

### 🔍 Security Summary:
- **Critical Vulnerabilities:** ${buildInfo.criticalVulns ?: '0'}
- **High Vulnerabilities:** ${buildInfo.highVulns ?: '0'}
- **Medium Vulnerabilities:** ${buildInfo.mediumVulns ?: '0'}

### 📝 Changelog:
${generateChangelog(version)}

### 🔗 Links:
- [Build Details](${buildInfo.buildUrl})
- [Test Report](${buildInfo.buildUrl}/testReport)
- [Security Report](${buildInfo.buildUrl}/Trivy_Security_Report_(Local)/)

---
*This release was automatically generated by Jenkins CI/CD Pipeline*
"""
        return template
    }
    
    def generateChangelog(String version) {
        try {
            def lastTag = steps.sh(
                script: "git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo ''",
                returnStdout: true
            ).trim()
            
            if (lastTag) {
                def commits = steps.sh(
                    script: "git log ${lastTag}..HEAD --pretty=format:'- %s' --no-merges",
                    returnStdout: true
                ).trim()
                
                return commits ?: "- No changes detected"
            } else {
                return "- Initial release"
            }
        } catch (Exception e) {
            return "- Unable to generate changelog: ${e.getMessage()}"
        }
    }
    
    def uploadReleaseAssets(String tag, List<String> assetPaths) {
        steps.echo "📎 Uploading assets to release ${tag}..."
        
        assetPaths.each { assetPath ->
            if (steps.fileExists(assetPath)) {
                steps.sh """
                    gh release upload "${tag}" "${assetPath}" --clobber
                """
                steps.echo "✅ Uploaded ${assetPath}"
            } else {
                steps.echo "⚠️  Asset not found: ${assetPath}"
            }
        }
    }
    
    def createDraftRelease(String tag, String title, String notes) {
        steps.echo "📝 Creating draft release ${tag}..."
        
        steps.sh """
            gh release create "${tag}" \
                --title "${title}" \
                --notes "${notes}" \
                --draft
        """
        
        steps.echo "✅ Draft release ${tag} created"
    }
    
    def publishRelease(String tag) {
        steps.echo "📢 Publishing release ${tag}..."
        
        steps.sh """
            gh release edit "${tag}" --draft=false
        """
        
        steps.echo "✅ Release ${tag} published"
    }
}